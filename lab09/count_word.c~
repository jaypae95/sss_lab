/* ----------------------------------------------------------------------------------------------------
 *  파일: counter_word.c
 *  기능 : 장문의 각 단어의 개수를 세고, 단어의 종류를 파일에 저장 (스레드 사용x)
 *  개발자: 201520934 배재훈 
 *  날짜	: 1차 개발 : 2018년 5월 11일 
 *----------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/time.h>

int fd;
FILE *fp;
char *arr;
void parse();
void count();
int num=0, wasspace=0, totalnum = 0, off = 0;
int word[1024] = {0};

int main() {
		struct timeval start, end; //시간측정
		long long startusec, endusec; // "
		double elapsed; // "
		
		gettimeofday(&start, NULL); // "
		arr = (char*)malloc(sizeof(char)*20);
		int i;
		if((fd = open("./long.txt", O_RDONLY))<0) { //long.txt 읽기모드로 열기
				printf("fail to open \"./long.txt\"\n");
				return 0;
		}
		fp = fopen("./tmp.txt", "w+"); //tmp.txt 파일 쓰기모드로 생성 후 열기
		parse(); //파일의 단어를 파싱해서 tmp파일에 저장
		fclose(fp); //파일 닫아줌
		fp = fopen("./word.txt", "w+"); //word.txt 파일 쓰기모드로 생성 후 열기
		count(); //각 단어의 개수를 세고 종류를 파일에 저장하는 함수

		char *buf = (char*)malloc(sizeof(char)*20);
		fseek(fp, 0, SEEK_SET); //파일의 위치를 처음으로 설정
		for(i = 0; i<num; i++) { //각 단어의 개수 출력
				fgets(buf, 20, fp);
				buf[strlen(buf)-1] = '\0';
				printf("%s : ", buf);
				printf("%d\n", word[i]);
		}
		fclose(fp); //파일 닫아줌

		gettimeofday(&end, NULL); //시간측정
		startusec = start.tv_sec * 1000000 + start.tv_usec;
		endusec = end.tv_sec * 1000000 + end.tv_usec;
		elapsed = (double)(endusec-startusec) / 1000000.0;
		printf("time : %.4fseconds\n", elapsed); //시간출력
}

void count() {
		FILE *fp2;
		char alph;
		int k=1;
		char *buf = (char*)malloc(sizeof(char)*20);
		char *infile = (char*)malloc(sizeof(char)*20);
		int isinfile=0;
		int pos=-1;

		fp2 = fopen("./tmp.txt", "r");

		while(1) {
				if(fgets(buf, 20, fp2) == 0) {
						break;
				}
				buf[strlen(buf)-1] = '\0';
				fseek(fp, 0, SEEK_SET);
				while(fgets(infile, 20, fp) != 0) {
						pos++;
						infile[strlen(infile)-1] = '\0';
						if(!strcmp(infile, buf)) {
								isinfile = 1;
								memset(infile, 0, strlen(infile));
								break;
						}
						memset(infile, 0, strlen(infile));
				}
				if(isinfile==0) {
						fseek(fp, 0, SEEK_END);
						fprintf(fp, "%s\n", buf);
						word[num]++;
						num++;
						pos = -1;
						memset(buf, 0, strlen(buf));
				}
				else {
						word[pos]++;
						pos = -1;
						memset(buf, 0, strlen(buf));
						isinfile = 0;
				}
		}
}

void parse() {
		char* infile = (char*)malloc(sizeof(char)*20);
		int res;
		char alph;
		int index=0;
		while(1) {
				if((res = read(fd, &alph, 1)==0)) {
						break;
				}
				if(res < 0) {
						return;
				}
				if(alph == ' ' || alph == '\n') {
						if(wasspace == 1) {
								continue;
						}
						fseek(fp, 0, SEEK_SET);
								arr[index] = '\0';
								fseek(fp, 0, SEEK_END);
								fprintf(fp, "%s\n", arr);
								totalnum++;
								index=0;
								wasspace = 1;
								memset(arr, 0, strlen(arr));						
				}
				else if(isalpha((int)alph) || alph == '-' || alph == '\'') {
						if(isupper((int)alph)) {
								alph += 32;
						}
								arr[index++] = alph;
								wasspace = 0;
				}
		}
	return;
}
